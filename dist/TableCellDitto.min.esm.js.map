{"version":3,"sources":["TableCellDitto.esm.js"],"names":["_thisElement","_dittoMark","_dittoMarkWidth","_supportCSSTypedOM","__classPrivateFieldSet","this","receiver","privateMap","value","has","TypeError","set","__classPrivateFieldGet","get","HtmlElementText","[object Object]","thisElement","dittoMark","tdElement","querySelector","htmlElementText","getWidth","undefined","attributeStyleMap","dittoTbodyElement","getElementsByTagName","aboveTrCellText","nonTargetRows","maxRowspan","aboveMaxRowspan","trCount","dittoTrElement","nonTargetRowsClear","tdCount","dittoTdElement","firstChild","cellText","textContent","rowspan","rowSpan","push","includes","computedStyleMap","paddingStart","CSS","px","Math","round","sub","div","add","paddingEnd","getComputedStyle","textAlign","paddingInlineStart","style","String","paddingInlineEnd","title","length","undittoTdElement","querySelectorAll","undittoCellNode","nodeValue","delete","removeAttribute","WeakMap"],"mappings":"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","file":"TableCellDitto.esm.js","sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _thisElement, _dittoMark, _dittoMarkWidth, _supportCSSTypedOM;\nimport HtmlElementText from '../../htmlelement-text/dist/HtmlElementText.esm.js';\n/**\n * Display the data cell with the same content as the cell directly above in <tbody> with a ditto mark.\n *\n * † Does not support tables with horizontal joins by the `colspan` attribute (`rowspan` attribute is supported).\n * † The `title` attribute cannot be specified in the <td> element (it will be overwritten by this function).\n *\n * @version 1.0.0\n */\nexport default class {\n    /**\n     * @param {HTMLTableElement} thisElement - Target element\n     * @param {string} dittoMark - Ditto mark\n     */\n    constructor(thisElement, dittoMark = '\"') {\n        _thisElement.set(this, void 0); // 対象要素\n        _dittoMark.set(this, void 0); // ノノ字点\n        _dittoMarkWidth.set(this, 0); // ノノ字点の幅\n        _supportCSSTypedOM.set(this, void 0); // CSS Typed Object Model に対応しているか（Chrome 66+） https://caniuse.com/mdn-api_element_attributestylemap\n        __classPrivateFieldSet(this, _thisElement, thisElement);\n        __classPrivateFieldSet(this, _dittoMark, dittoMark);\n        const tdElement = thisElement.querySelector('tbody td');\n        if (tdElement !== null) {\n            const htmlElementText = new HtmlElementText(tdElement);\n            __classPrivateFieldSet(this, _dittoMarkWidth, htmlElementText.getWidth(dittoMark));\n        }\n        __classPrivateFieldSet(this, _supportCSSTypedOM, thisElement.attributeStyleMap !== undefined);\n    }\n    /**\n     * Replace with ditto mark\n     */\n    convert() {\n        for (const dittoTbodyElement of __classPrivateFieldGet(this, _thisElement).getElementsByTagName('tbody')) {\n            const aboveTrCellText = []; // 直上行のセルの中身\n            const nonTargetRows = []; // 置換対象外の列番号\n            let maxRowspan = 1; // 行内セルの rowspan 属性最大値\n            let aboveMaxRowspan = 1; // 直上行内セルの rowspan 属性最大値\n            let trCount = 0; // <tbody> 要素内における行数（何番目の <tr> 要素か）\n            for (const dittoTrElement of dittoTbodyElement.getElementsByTagName('tr')) {\n                if (maxRowspan === 1) {\n                    let nonTargetRowsClear = false;\n                    let tdCount = 0; // <tr> 要素内における <th> 要素を除いた列数（何番目の <td> 要素か）\n                    for (const dittoTdElement of dittoTrElement.getElementsByTagName('td')) {\n                        if (dittoTdElement.firstChild === null) {\n                            aboveTrCellText[tdCount] = '';\n                        }\n                        else {\n                            const cellText = dittoTdElement.textContent;\n                            const rowspan = dittoTdElement.rowSpan;\n                            if (rowspan > maxRowspan) {\n                                maxRowspan = rowspan;\n                            }\n                            else if (rowspan < maxRowspan) {\n                                nonTargetRows.push(tdCount);\n                            }\n                            if (!nonTargetRows.includes(tdCount)) {\n                                if (trCount > 0 && cellText === aboveTrCellText[tdCount]) {\n                                    if (rowspan > 1 || (maxRowspan === 1 && rowspan === 1)) {\n                                        /* 表示位置調整 */\n                                        if (__classPrivateFieldGet(this, _supportCSSTypedOM)) {\n                                            switch (dittoTdElement.computedStyleMap().get('text-align').value) {\n                                                case 'start': {\n                                                    const htmlElementText = new HtmlElementText(dittoTdElement);\n                                                    const paddingStart = dittoTdElement.computedStyleMap().get('padding-inline-start');\n                                                    dittoTdElement.attributeStyleMap.set('padding-inline-start', CSS.px(Math.round(htmlElementText.getWidth())).sub(CSS.px(__classPrivateFieldGet(this, _dittoMarkWidth))).div(2).add(paddingStart));\n                                                    break;\n                                                }\n                                                case 'end': {\n                                                    const htmlElementText = new HtmlElementText(dittoTdElement);\n                                                    const paddingEnd = dittoTdElement.computedStyleMap().get('padding-inline-end');\n                                                    dittoTdElement.attributeStyleMap.set('padding-inline-end', CSS.px(Math.round(htmlElementText.getWidth())).sub(CSS.px(__classPrivateFieldGet(this, _dittoMarkWidth))).div(2).add(paddingEnd));\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        else {\n                                            switch (getComputedStyle(dittoTdElement, '').textAlign) {\n                                                case 'start': {\n                                                    const htmlElementText = new HtmlElementText(dittoTdElement);\n                                                    const paddingStart = getComputedStyle(dittoTdElement).paddingInlineStart;\n                                                    dittoTdElement.style.paddingInlineStart = `calc((${String(Math.round(htmlElementText.getWidth()))}px - ${__classPrivateFieldGet(this, _dittoMarkWidth)}px) / 2 + ${paddingStart})`;\n                                                    break;\n                                                }\n                                                case 'end': {\n                                                    const htmlElementText = new HtmlElementText(dittoTdElement);\n                                                    const paddingEnd = getComputedStyle(dittoTdElement).paddingInlineEnd;\n                                                    dittoTdElement.style.paddingInlineEnd = `calc((${String(Math.round(htmlElementText.getWidth()))}px - ${__classPrivateFieldGet(this, _dittoMarkWidth)}px) / 2 + ${paddingEnd})`;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        dittoTdElement.title = cellText;\n                                        dittoTdElement.textContent = __classPrivateFieldGet(this, _dittoMark);\n                                    }\n                                }\n                            }\n                            aboveTrCellText[tdCount] = cellText;\n                        }\n                        if (!nonTargetRowsClear && nonTargetRows.includes(tdCount) && aboveMaxRowspan > 1 && maxRowspan === 1) {\n                            nonTargetRowsClear = true;\n                        }\n                        tdCount++;\n                    }\n                    if (nonTargetRowsClear) {\n                        nonTargetRows.length = 0;\n                    }\n                    aboveMaxRowspan = maxRowspan;\n                }\n                if (maxRowspan > 1) {\n                    maxRowspan--;\n                }\n                trCount++;\n            }\n        }\n    }\n    /**\n     * Stop replacing with ditto mark\n     */\n    unConvert() {\n        for (const undittoTdElement of __classPrivateFieldGet(this, _thisElement).querySelectorAll('tbody td')) {\n            const undittoCellNode = undittoTdElement.firstChild;\n            if (undittoCellNode !== null && undittoCellNode.nodeValue === __classPrivateFieldGet(this, _dittoMark)) {\n                /* 表示位置戻す */\n                if (__classPrivateFieldGet(this, _supportCSSTypedOM)) {\n                    switch (undittoTdElement.computedStyleMap().get('text-align').value) {\n                        case 'start': {\n                            undittoTdElement.attributeStyleMap.delete('padding-inline-start');\n                            break;\n                        }\n                        case 'end': {\n                            undittoTdElement.attributeStyleMap.delete('padding-inline-end');\n                            break;\n                        }\n                    }\n                }\n                else {\n                    switch (getComputedStyle(undittoTdElement, '').textAlign) {\n                        case 'start': {\n                            undittoTdElement.style.paddingInlineStart = '';\n                            break;\n                        }\n                        case 'end': {\n                            undittoTdElement.style.paddingInlineEnd = '';\n                            break;\n                        }\n                    }\n                }\n                undittoTdElement.textContent = undittoTdElement.title;\n                undittoTdElement.removeAttribute('title');\n            }\n        }\n    }\n}\n_thisElement = new WeakMap(), _dittoMark = new WeakMap(), _dittoMarkWidth = new WeakMap(), _supportCSSTypedOM = new WeakMap();\n"]}